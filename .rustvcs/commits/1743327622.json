{
  "files": {
    "src/add.rs": "use std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\npub fn add_file(path: &str) {\n    let vcs_dir = \".rustvcs\";\n    let staging_path = format!(\"{}/staging.json\", vcs_dir);\n\n    if !Path::new(vcs_dir).exists() {\n        println!(\"No repository found. Run `init` first.\");\n        return;\n    }\n\n    let mut staged_files = if Path::new(&staging_path).exists() {\n        let content = fs::read_to_string(&staging_path).unwrap();\n        serde_json::from_str::<HashMap<String, String>>(&content).unwrap_or_default()\n    } else {\n        HashMap::new()\n    };\n\n    let target_path = Path::new(path);\n    if target_path.is_file() {\n        let content = fs::read_to_string(target_path).unwrap();\n        staged_files.insert(path.to_string(), content);\n    } else if target_path.is_dir() {\n        add_directory(target_path, &mut staged_files);\n    } else {\n        println!(\"Invalid path: '{}'\", path);\n        return;\n    }\n\n    fs::write(\n        &staging_path,\n        serde_json::to_string_pretty(&staged_files).unwrap(),\n    )\n    .unwrap();\n    println!(\"Added '{}' to staging.\", path);\n}\n\nfn add_directory(dir: &Path, staged_files: &mut HashMap<String, String>) {\n    for entry in fs::read_dir(dir).unwrap() {\n        let entry = entry.unwrap();\n        let path = entry.path();\n\n        if path.is_dir() {\n            add_directory(&path, staged_files); // Recurse into subdirectories\n        } else if path.is_file() {\n            let relative_path = path.to_str().unwrap().to_string();\n            if !relative_path.starts_with(\".rustvcs\") {\n                let content = fs::read_to_string(&path).unwrap();\n                staged_files.insert(relative_path, content);\n            }\n        }\n    }\n}\n",
    "src/branch.rs": "use serde_json::Value;\nuse std::fs;\nuse std::path::Path;\n\npub fn create_branch(branch_name: &str) {\n    let vcs_dir = \".rustvcs\";\n    let head_path = format!(\"{}/HEAD\", vcs_dir);\n    let branch_path = format!(\"{}/branches/{}.json\", vcs_dir, branch_name);\n\n    if !Path::new(&head_path).exists() {\n        println!(\"No repository found. Run `init` first.\");\n        return;\n    }\n\n    if Path::new(&branch_path).exists() {\n        println!(\"Branch '{}' already exists.\", branch_name);\n        return;\n    }\n\n    let current_branch = fs::read_to_string(&head_path).unwrap_or(\"main\".to_string());\n    let current_branch_path = format!(\"{}/branches/{}.json\", vcs_dir, current_branch);\n\n    if !Path::new(&current_branch_path).exists() {\n        println!(\"Current branch has no commits yet.\");\n        return;\n    }\n\n    let latest_commit = fs::read_to_string(&current_branch_path).unwrap();\n    fs::write(&branch_path, &latest_commit).unwrap();\n    fs::write(&head_path, branch_name).unwrap(); // Switch HEAD to new branch\n    println!(\"Switched to new branch '{}'.\", branch_name);\n}\n",
    "src/checkout.rs": "use serde_json::Value;\nuse std::fs;\nuse std::path::Path;\npub fn checkout(branch_or_commit: &str) {\n    let vcs_dir = \".rustvcs\";\n    let head_path = format!(\"{}/HEAD\", vcs_dir);\n    let branch_path = format!(\"{}/branches/{}.json\", vcs_dir, branch_or_commit);\n    let commit_path = format!(\"{}/commits/{}.json\", vcs_dir, branch_or_commit);\n\n    if Path::new(&branch_path).exists() {\n        fs::write(&head_path, branch_or_commit).unwrap(); // Update HEAD\n        println!(\"Switched to branch '{}'.\", branch_or_commit);\n    } else if Path::new(&commit_path).exists() {\n        let content = fs::read_to_string(&commit_path).unwrap();\n        let commit: serde_json::Value = serde_json::from_str(&content).unwrap();\n\n        for (filename, file_content) in commit[\"files\"].as_object().unwrap() {\n            fs::write(filename, file_content.as_str().unwrap()).unwrap();\n        }\n\n        println!(\"Checked out commit {}\", branch_or_commit);\n    } else {\n        println!(\"Branch or commit '{}' not found.\", branch_or_commit);\n    }\n}\n",
    "src/commit.rs": "use serde_json::json;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\npub fn commit_changes(message: &str) {\n    let vcs_dir = \".rustvcs\";\n    let head_path = format!(\"{}/HEAD\", vcs_dir);\n    let commits_dir = format!(\"{}/commits\", vcs_dir);\n    let branches_dir = format!(\"{}/branches\", vcs_dir);\n\n    if !Path::new(&head_path).exists() {\n        println!(\"No repository found. Run `init` first.\");\n        return;\n    }\n\n    let branch = fs::read_to_string(&head_path).unwrap_or(\"main\".to_string());\n    let branch_path = format!(\"{}/{}.json\", branches_dir, branch);\n\n    // Create commit ID (for simplicity, using timestamp)\n    let commit_id = format!(\"{}\", chrono::Utc::now().timestamp());\n    let commit_path = format!(\"{}/{}.json\", commits_dir, commit_id);\n\n    // Collect all tracked files\n    let mut files = HashMap::new();\n    for entry in fs::read_dir(\".\").unwrap() {\n        let entry = entry.unwrap();\n        let path = entry.path();\n        if path.is_file() && path.extension().unwrap_or_default() != \"json\" {\n            let content = fs::read_to_string(&path).unwrap();\n            files.insert(path.to_str().unwrap().to_string(), content);\n        }\n    }\n\n    let commit_data = json!({\n        \"id\": commit_id,\n        \"message\": message,\n        \"files\": files\n    });\n\n    fs::write(\n        &commit_path,\n        serde_json::to_string_pretty(&commit_data).unwrap(),\n    )\n    .unwrap();\n    fs::write(\n        &branch_path,\n        serde_json::to_string_pretty(&commit_data).unwrap(),\n    )\n    .unwrap();\n\n    println!(\"Committed as {}\", commit_id);\n}\n",
    "src/init.rs": "use std::fs;\nuse std::path::Path;\n\npub fn init_repo() {\n    let vcs_dir = \".rustvcs\";\n    let commits_dir = format!(\"{}/commits\", vcs_dir);\n    let branches_dir = format!(\"{}/branches\", vcs_dir);\n    let head_path = format!(\"{}/HEAD\", vcs_dir);\n    let main_branch_path = format!(\"{}/main.json\", branches_dir);\n\n    if Path::new(vcs_dir).exists() {\n        println!(\"Repository already initialized.\");\n        return;\n    }\n\n    fs::create_dir_all(&commits_dir).unwrap();\n    fs::create_dir_all(&branches_dir).unwrap();\n    fs::write(&head_path, \"main\").unwrap(); // Initialize HEAD to 'main'\n\n    println!(\"Initialized empty RustVCS repository in {}\", vcs_dir);\n}\n",
    "src/log.rs": "use serde_json::Value;\nuse std::fs;\nuse std::path::Path;\n\npub fn show_log() {\n    let vcs_dir = \".rustvcs/commits\";\n\n    if !Path::new(vcs_dir).exists() {\n        println!(\"No commit history.\");\n        return;\n    }\n\n    let entries = fs::read_dir(vcs_dir).unwrap();\n    for entry in entries {\n        let path = entry.unwrap().path();\n        if path.is_file() {\n            let content = fs::read_to_string(&path).unwrap();\n            let commit: Value = serde_json::from_str(&content).unwrap();\n            println!(\n                \"Commit {}: {} at {}\",\n                commit[\"id\"], commit[\"message\"], commit[\"timestamp\"]\n            );\n        }\n    }\n}\n",
    "src/main.rs": "use add::add_file;\nuse branch::create_branch;\nuse checkout::checkout;\nuse commit::commit_changes;\nuse init::init_repo;\nuse log::show_log;\nuse merge::merge_branch;\n\nmod add;\nmod branch;\nmod checkout;\nmod commit;\nmod init;\nmod log;\nmod merge;\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() > 1 && args[1] == \"init\" {\n        init_repo();\n    } else if args.len() > 2 && args[1] == \"add\" {\n        add_file(&args[2]);\n    } else if args.len() > 2 && args[1] == \"commit\" {\n        commit_changes(&args[2]);\n    } else if args.len() > 1 && args[1] == \"log\" {\n        show_log();\n    } else if args.len() > 2 && args[1] == \"checkout\" {\n        checkout(&args[2]);\n    } else if args.len() > 2 && args[1] == \"branch\" {\n        create_branch(&args[2]);\n    } else if args.len() > 2 && args[1] == \"merge\" {\n        merge_branch(&args[2]);\n    }\n}\n",
    "src/merge.rs": "use serde_json::Value;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\npub fn merge_branch(target_branch: &str) {\n    let vcs_dir = \".rustvcs\";\n    let head_path = format!(\"{}/HEAD\", vcs_dir);\n    let current_branch = fs::read_to_string(&head_path).unwrap_or(\"main\".to_string());\n\n    if current_branch == target_branch {\n        println!(\"Already on '{}'. Nothing to merge.\", target_branch);\n        return;\n    }\n\n    let target_branch_path = format!(\"{}/branches/{}.json\", vcs_dir, target_branch);\n    let current_branch_path = format!(\"{}/branches/{}.json\", vcs_dir, current_branch);\n\n    if !Path::new(&target_branch_path).exists() {\n        println!(\"Branch '{}' does not exist.\", target_branch);\n        return;\n    }\n\n    // Load latest commits of both branches\n    let target_commit: Value =\n        serde_json::from_str(&fs::read_to_string(&target_branch_path).unwrap()).unwrap();\n    let mut current_commit: Value =\n        serde_json::from_str(&fs::read_to_string(&current_branch_path).unwrap()).unwrap();\n\n    let target_files = target_commit[\"files\"].as_object().unwrap();\n    let current_files = current_commit[\"files\"].as_object_mut().unwrap();\n\n    // Simple merge: copy new/updated files from target to current\n    for (file, content) in target_files {\n        current_files.insert(file.clone(), content.clone());\n    }\n\n    // Save merged commit\n    let new_commit_path = format!(\n        \"{}/commits/{}.json\",\n        vcs_dir,\n        current_commit[\"id\"].as_str().unwrap()\n    );\n    fs::write(\n        new_commit_path,\n        serde_json::to_string_pretty(&current_commit).unwrap(),\n    )\n    .unwrap();\n    fs::write(\n        current_branch_path,\n        serde_json::to_string_pretty(&current_commit).unwrap(),\n    )\n    .unwrap();\n\n    println!(\"Merged '{}' into '{}'.\", target_branch, current_branch);\n}\n"
  },
  "id": "1743327622",
  "message": "empty commit"
}